# -*- python -*-
# ex: set syntax=python:

import re
import posixpath, ntpath

c = BuildmasterConfig = {}
####### BUILDSLAVES
from buildbot.buildslave import BuildSlave

slave_names = {
    'x86-win32': ['sdwilsh-windows%i' % x for x in range(1,5)],
    'x86-fedora': ['johnford.info-slave1'],
    'x86-freebsd': ['robarnold-slave%i' % x for x in range(1,3)],
    'x86_64-osx': ['zpao-slave%i' % x for x in range(1,3)] +
                  ['gavin-slave%i' % x for x in range(1,3)],
}
slaves = {}
c['slaves'] = []
for platform in slave_names.keys():
    slaves[platform] = []
    for i in slave_names[platform]:
      slave = BuildSlave(i, "password", max_builds=1)
      slaves[platform].append(slave)
      c['slaves'].append(slave)
c['slavePortnum'] = 9989

####### BUILDERS
from buildbot.process.factory import BuildFactory
from buildbot.steps.source import Git
from buildbot.steps.shell import Configure, Compile, ShellCommand, SetProperty
from buildbot.steps.transfer import FileDownload
from buildbot.process.properties import WithProperties

def argv_conv(platform, cmd):
    if 'win32' in platform:
        if type(cmd) is str:
            str_cmd = cmd
        else:
            str_cmd = ' '.join(cmd)
        real_cmd = "sh -c '" + str_cmd + "'"
    else:
        real_cmd = cmd
    print platform, '\t', real_cmd
    return real_cmd

def make(platform, target=None, file=None, dir=None, vars=None,
         keep_going=False):
    #FreeBSD uses gmake for GNU Make
    if 'freebsd' in platform:
        cmd_list = ['gmake']
    else:
        cmd_list = ['make']
    if keep_going:
        cmd_list.append('-k')
    if file:
        cmd_list.extend(['-f', file])
    if dir:
        cmd_list.extend(['-C', dir])
    if target:
        cmd_list.append(target)
    if vars:
        assert type(vars) is dict, "make vars should be in dict"
        for key in vars.keys():
            cmd_list.append("%s=%s" % (key, vars[key]))
    return argv_conv(platform, cmd_list)

from buildbot.status.builder import FAILURE, SUCCESS, WARNINGS, worst_status

class TestShellCommand(ShellCommand):
    def __init__(self, **kwargs):
        self.super_class = ShellCommand
        self.super_class.__init__(self, **kwargs)

    def parse_log(self, log_text):
        # should probably do something here to make this only
        # run once
        some_passes = 'TEST-PASS' in log_text
        a_failure = 'TEST-UNEXPECTED' in log_text
        all_strings = re.findall("\d+ of \d+ tests passed", log_text, re.M)
        line_pattern = re.compile("(?P<pass>\d+) of (?P<total>\d+) tests passed")
        passes = 0
        total = 0
        for string in all_strings:
            m = line_pattern.search(string)
            passes += int(m.group('pass'), 10)
            total += int(m.group('total'), 10)
        msg = "%i/%i/%i" % (passes, total-passes, total)
        if a_failure and (total-passes) == 0:
            msg += "\nTEST RESULT PARSER BUSTED, THERE ARE FAILURES"
        self.passes = passes
        self.failures = total-passes
        self.total = total
        self.msg = msg


    def createSummary(self, log):
        log_text=log.getText()
        self.parse_log(log_text)
        self.addCompleteLog('test-results', self.msg)

    def evaluateCommand(self, cmd):
        superResult = self.super_class.evaluateCommand(self, cmd)
        if superResult == FAILURE:
            superResult = WARNINGS
        log_text = cmd.logs['stdio'].getText()
        self.parse_log(log_text)
        if self.passes == 0 or self.failures >= 1 or self.total == 0:
            return worst_status(superResult, WARNINGS)
        else:
            return worst_status(superResult, SUCCESS)


class ScriptBuild(BuildFactory):
    warnOnWarnings = True
    flunkOnWarnings = False

    def __init__(self, platform, build_style,
                 test_dirs=[], **kwargs):
        self.platform = platform
        self.build_style = build_style
        self.test_dirs = test_dirs[:]
        BuildFactory.__init__(self, **kwargs)

        # Use buildbot to checkout sources
        self.addStep(Git(
            repourl='git://github.com/zpao/v8monkey.git',
            branch='master',
            mode='update',
        ))
        self.addStep(FileDownload(
            mastersrc="build.sh",
            slavedest="build.sh",
            workdir='.',
        ))
        self.addStep(ShellCommand(
            name="build_script",
            command=argv_conv(self.platform,
                ['bash', 'build.sh', platform, build_style]),
            workdir='.',
        ))
        for test_dir in self.test_dirs:
            self.addStep(TestShellCommand(
                name="make_check_%s" % test_dir.replace("/", "_"),
                command=make(self.platform,
                             target='check',
                             keep_going=True,
                             dir=test_dir),
                workdir="objdir",
                warnOnWarnings=True,
                flunkOnWarnings=True,
            ))


class NodeMonkeyFactory(BuildFactory):

  def __init__(self, platform, branch='master',
               build_style='opt', test_dirs=[],
               **kwargs):
      self.platform = platform
      self.branch = branch
      assert branch == 'master', 'hmm, lets not use this'
      self.build_style = style
      self.test_dirs = test_dirs[:]
      BuildFactory.__init__(self, **kwargs)
      self.add_setup_steps()
      self.add_source_steps()
      self.add_build_steps()
      self.add_package_steps()
      self.add_upload_steps()
      self.add_test_steps()

  def add_setup_steps(self):
      self.addStep(ShellCommand(
          name='clobber_objdir',
          command=argv_conv(self.platform, ['rm', '-rf', 'objdir']),
          workdir=".",
      ))

  def add_source_steps(self):
    self.addStep(Git(
        repourl='git://github.com/zpao/v8monkey.git',
        branch=self.branch,
        mode='update'))

  def add_build_steps(self):
    autoconf_bin = 'autoconf213' if 'osx' in self.platform else 'autoconf-2.13'
    configure_arg_list = []
    if self.build_style == 'opt':
        configure_arg_list.append('--enable-optimize')
        configure_arg_list.append('--enable-tests')
    elif self.build_style == 'debug':
        configure_arg_list.append('--disable-optimize')
        configure_arg_list.append('--enable-debug')

    if 'win32' in platform:
        configure_arg_list.append('--target=i686-pc-mingw32')

    if not 'win32' in platform:
        configure_arg_list.append('--with-ccache')

    # Windows needs to build NSPR for spidermonkey to work correctly.
    if 'win32' in self.platform:
        self.addStep(ShellCommand(
            name='autoconf_nspr',
            command=argv_conv(self.platform, [autoconf_bin]),
            workdir="build/nsprpub"))
        nspr_conf_arg_list = [
            '--prefix=$(sh pwd)/dist',
            '--with-dist-prefix=$(sh pwd)/dist',
            '--with-mozilla',
        ]
        self.addStep(Configure(
            name="configure_nspr",
            command=argv_conv(self.platform,
                ['sh', '../build/nsprpub/configure'] + \
                        nspr_conf_arg_list + configure_arg_list),
            workdir="objdir"))

        self.addStep(Compile(
            name="compile_nspr",
            workdir="objdir",
            command=make(self.platform)))

        self.addStep(ShellCommand(
            name='nspr install',
            command=make(self.platform, target='install'),
            workdir="objdir"))

    self.addStep(ShellCommand(
        name='autoconf',
        command=argv_conv(self.platform, [autoconf_bin]),
        workdir="build/js/src"))

    # Windows needs to use the custom build nspr.
    if 'win32' in self.platform:
        nspr_lib_dir = '$(sh pwd)/dist'
        nspr_include_dir = 'dist/include'
        nspr_lib_files = ('plds4.lib', 'plc4.lib', 'nspr4.lib')
        nspr_libs = ' '.join(['%s/%s' % (nspr_lib_dir, x) for x in nspr_lib_files])
        nspr_extra_config = [
            '--with-nspr-prefix=dist',
            '--with-nspr-libs="%s"' % nspr_libs,
            '--with-nspr-cflags="-I%s"' % nspr_include_dir,
        ]
        configure_arg_list.extend(nspr_extra_config)

        self.addStep(SetProperty(
            command="echo %PATH%",
            property="slave_path_var",
        ))
        self.addStep(SetProperty(
            command="echo %cd%",
            property="windows_pwd",
            workdir="objdir",
        ))
        configure_env = {"PATH": \
            WithProperties(r"%(windows_pwd)s\dist\lib;%(windows_pwd)s\dist\bin;%(slave_path_var)s")}
    else:
        configure_env = {}
    self.addStep(Configure(
        command=argv_conv(self.platform,
                  ['sh', '../build/js/src/configure'] + configure_arg_list),
        workdir="objdir",
        env=configure_env,
    ))


    self.addStep(Compile(
        workdir="objdir",
        command=make(self.platform)))

  #methods stubbed out for now
  def add_package_steps(self):
    pass
  def add_upload_steps(self):
    pass

  def add_test_steps(self):
    for test_dir in self.test_dirs:
        self.addStep(TestShellCommand(
            name="make_check_%s" % test_dir.replace("/", "_"),
            command=make(self.platform,
                         target='check',
                         keep_going=True,
                         dir=test_dir),
            workdir="objdir"))


from buildbot.scheduler import AnyBranchScheduler
from buildbot.config import BuilderConfig

c['builders'] = []
c['schedulers'] = []
branch_builders = []
for platform in slave_names.keys():
    for style in ('opt', 'debug'):
        builder_name = "%s-%s" % (platform, style)
        branch_builders.append(builder_name)
        factory = ScriptBuild(
                      platform=platform,
                      build_style=style,
                      test_dirs=['v8api/test'],
                  )
        c['builders'].append(
            BuilderConfig(
                name=builder_name,
                slavenames=slave_names[platform],
                category=platform,
                factory=factory))
c['schedulers'].append(AnyBranchScheduler(
                           name='spidernode-scheduler',
                           treeStableTimer=None,
                           builderNames=branch_builders))
####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

### HTML STATUS AND GITHUB CHANGES
from buildbot.status import html
from buildbot.status.web import auth, authz
f=open('password')
password=f.read().strip()
f.close()
users = [('admin', password)]
authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth(users),
    gracefulShutdown = 'auth',
    forceBuild = True, # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = 'auth',
    stopBuild = 'auth',
    stopAllBuilds = False,
    cancelPendingBuild = 'auth',
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg,
                                  change_hook_dialects={'github': True}))

### IRC BOT
notify_events={
    'failureToSuccess': 1,
    'warningsToSuccess': 1,
    'exceptionToSuccess': 1,
    'successToFailure': 1,
    'successToWarnings': 1,
    'exception': 1,
}
from buildbot.status.words import IRC
c['status'].append(IRC(host='irc.mozilla.org', nick='gertrude', 
                       channels=['#spidernode'], port=6697, useSSL=True,
                       showBlameList=True,
                       notify_events=notify_events))

### EMAIL
from buildbot.status.mail import VALID_EMAIL
from zope.interface import implements
from buildbot import interfaces, util

class GithubDomain(util.ComparableMixin):
    implements(interfaces.IEmailLookup)

    def __init__(self):
        self.pattern = re.compile("(%s)" % VALID_EMAIL.pattern)

    def getAddress(self, user):
        return self.pattern.search(user).group(0)

from buildbot.status.mail import MailNotifier
c['status'].append(MailNotifier(fromaddr="gertrude@johnford.info",
                                sendToInterestedUsers=True,
                                mode='problem',
                                lookup=GithubDomain(),
                                extraRecipients=[]))

####### PROJECT IDENTITY
c['projectName'] = "spidernode"
c['projectURL'] = "https://github.com/zpao/v8monkey"
c['buildbotURL'] = "http://johnford.info:8010/"

####### DB URL
c['db_url'] = "sqlite:///state.sqlite"

